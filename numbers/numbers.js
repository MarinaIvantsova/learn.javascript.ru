// 1. Создайте скрипт, который запрашивает ввод двух чисел (используйте prompt) и после показывает их сумму.
let a = +prompt('a:', 0);
let b = +prompt('b:', 0);

console.log(a + b);

/*
2. Почему 6.35.toFixed(1) == 6.3?
Методы Math.round и toFixed, согласно документации,
округляют до ближайшего целого числа: 0..4 округляется в меньшую сторону, тогда как 5..9 в большую сторону.

Например:

console.log( 1.35.toFixed(1) ); // 1.4
Но почему в примере ниже 6.35 округляется до 6.3?

console.log( 6.35.toFixed(1) ); // 6.3
Как правильно округлить 6.35?
*/ 

/* Решение:

Почему 6.35.toFixed(1) == 6.3? Во внутреннем двоичном представлении 6.35 является бесконечной двоичной дробью.
Хранится она с потерей точности…

console.log( 6.35.toFixed(20) ); // 6.34999999999999964473 

Потеря точности может как увеличивать, так и уменьшать число.
В данном случае число становится чуть меньше, поэтому оно округляется в меньшую сторону.

Для числа 1.35:

console.log( 1.35.toFixed(20) ); // 1.35000000000000008882

Тут потеря точности приводит к увеличению числа, поэтому округление произойдёт в большую сторону.

Каким образом можно исправить ошибку в округлении числа 6.35?

Мы должны приблизить его к целому числу, перед округлением:

console.log( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
Для числа 63.5 не происходит потери точности. Десятичная часть 0.5 на самом деле 1/2.
Дробные числа, делённые на степень 2, точно представлены в двоичной системе, теперь мы можем округлить число:

console.log( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4
*/
